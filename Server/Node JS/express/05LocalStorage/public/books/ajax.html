<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ajax Version</title>
    <style>
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }
        th, td {
            padding: 5px;
        }
        a { cursor: pointer; color: blue; }
        a:hover,a.hover { text-decoration: underline; }
    </style>
    <noscript>
        <meta http-equiv="refresh" content="0; url=/books/postback">
        <a href="/books/postback">Click here to redirect to noscript version</a>
    </noscript>
</head>
<body>
<a href="/logout">Logout</a><br><br>
<div id="display"></div>

<script   src="https://code.jquery.com/jquery-2.2.3.min.js"   integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo="   crossorigin="anonymous"></script>
<script src="/scripts/ejs.min.js"></script>
<script>

    var BOOK_NS = {
        storage: window.sessionStorage,
        storagePrefix: 'CSE136',

        /*  variable used to store templates in a cache to prevent multiple requests on static file */
        templatesCache: [],

        /* variable to track the number of modifying requests that are in progress */
        reqsInProgress: 0,

        /* variable to track if we are on the list page or an edit page */
        inEditMode: 0,

        /*  list of items that have been updated before the server id was associated with record */
        updated: {},

        /* list of items that have been deleted before the server id was associated with record */
        deleted: {},

        /* How many times to retry request before aborting */
        requestLimit: 10
    };

    document.addEventListener("DOMContentLoaded", function(event) {
        var callback = setupEdit();
        loadList(callback);
    });

    /**
     * Determine if the page should be loaded with the list or with one of the edit pages
     * based on the hash.  This allows redirects from the noscript version as well as
     * bookmarking.
     */
     function setupEdit(){
        var id;
        var hash;
        var callback = null;

        if(window.location.hash) {
            hash = window.location.hash.substring(1);
            if (hash === 'add'){
                callback = showAdd;
            }
            else if (hash.indexOf('edit') !== -1){
                id = parseInt(hash.substring(4),10);
                callback = function(){showEdit(id)};
            }
            else if (hash.indexOf('delete') !== -1){
                id = parseInt(hash.substring(6),10);
                callback = function(){confirmDelete(id)};
            }
        }

        return callback;
    }

    /**
     * Capture back/forward button.
     * When the button is pressed, load the appropriate page and data based on the e.state
     */
    window.addEventListener('popstate', function(e) {
        var pageName = e.state.pageName;
        displayTemplate(BOOK_NS.templatesCache[pageName], e.state);
    });

    /**
     *   Adds Request to History
     *   Checks if template exists in the cache.  If so, calls displayTemplate.
     *   If not, first loads template and adds it to cache before calling displayTemplate.
     */
    function loadTemplate(name, data, callback){
        if (!callback) {
            addToHistory(name, data);
            BOOK_NS.inEditMode = (name !== 'list');
        }

        if (BOOK_NS.templatesCache[name]){
            displayTemplate(BOOK_NS.templatesCache[name], data, callback);
        }
        else{
            $.get('/views/books/' + name + '.ejs', function (template) {
                BOOK_NS.templatesCache[name] = template;
                displayTemplate(template, data, callback);
            });
        }
    }

    /**
     * Takes template string and data and uses EJS to render them together.
     * Then displays the new HTML inside of the display div.
     * If there is a callback, it means we need to load an editscreen after the list, so do not display list.
     */
    function displayTemplate(template, data, callback) {
        var snippet = ejs.render(template, data);
        if (callback){
            document.getElementById('display').style.display = "none";
        }
        else{
            document.getElementById('display').style.display = "";
        }

        document.getElementById('display').innerHTML = snippet;

        if (callback){
            callback();
        }
    }

    /**
     * Updates the data object to include the name of the page
     * Adds the request to history
     * Use current page name with hash to avoid 404s.
     * Could use node to reroute other paths if desired
     * Could add in function on load to check status to allow bookmarking.
     */
    function addToHistory(name, data){
        var id;
        data = data || {};

        if (data.book && data.book.id){
            id = data.book.id;
        }
        else{
            id = '';
        }

        data.pageName = name;
        history.pushState(data, null, '/books/ajax.html#' + name + id);
    }

    /**
     *  Uses Ajax to get the book list data from the server.
     */
    function loadList(callback, noFetch) {
        var storedList = BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books');

        //If there is a callback, we are loading a bookmarked page, so need the freshest data.
        // No need to check localStorage
        if (storedList && !callback){
            loadTemplate('list', {books: JSON.parse(storedList)},  callback);
        }

        if (!callback){
            BOOK_NS.inEditMode = false;
        }

        //On edit actions, we just want to get data from local storage until edit hits the server
        if (!noFetch) {
            $.get('/api/books/', function(books) {
                if (!BOOK_NS.inEditMode && BOOK_NS.reqsInProgress === 0) {
                    BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(books));
                    loadTemplate('list', {books: books}, callback);
                }
            });
        }
    }

    /**
     *  Displays the confirm delete page for the passed in book.
     */
    function confirmDelete(id) {
        var title = document.getElementById('title' + id).innerHTML;
        var book = {id: id, title: title};
        loadTemplate('delete', {book: book});
    }

    /**
     *  Uses Ajax to get delete the book from the server.  Calls loadList on success.
     */
    function deleteBook(id) {
        //First Remove from storage
        var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
        var currentItem = findStoredRecord(id);
        storedList.splice(currentItem.index, 1);
        BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(storedList));

        //Refresh grid from storage
        loadList(null, true);

        //Check if it is a new ID that has not been confirmed by the server yet
        if (currentItem.item.id === currentItem.item.tempId){
            BOOK_NS.deleted[currentItem.item.tempId] = true;
        }
        else {
            deleteFromServer(id);
        }
    }

    /**
     * Calls the server to delete the record
     */
     function deleteFromServer(id){
        //Make Ajax Request and load from server on success
        BOOK_NS.reqsInProgress++;
        $.ajax({
            url: '/api/books/' + id,
            type: 'DELETE',
            timeout:5000,
            requestAttempts: 1,
            error:onRequestError,
            success: onRequestSuccess
        });
     }

    /**
     *  Displays the add book page.
     */
    function showAdd() {
        loadTemplate('add');
    }

    /**
     *  Uses Ajax to add the new book from the server.  Calls loadList on success.
     */
    function addBook() {
        var title = document.getElementById('title').value;
        var author = document.getElementById('author').value;
        var price = document.getElementById('price').value;
        var tempId = getId();

        //Add to storage
        var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
        var currentItem = {};
        currentItem.title = title;
        currentItem.author = author;
        currentItem.price = price;
        currentItem.id = currentItem.tempId = tempId;
        storedList.push(currentItem);
        BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(storedList));

        //Refresh grid from storage
        loadList(null, true);

        //Make Ajax Request and update id in localstorage on success
        BOOK_NS.reqsInProgress++;

        $.ajax({
            url: '/api/books/',
            data: 'title=' + title + '&author=' + author + '&price=' + price,
            type: 'POST',
            timeout:5000,
            requestAttempts: 1,
            error:onRequestError,
            success: function(res){
                BOOK_NS.reqsInProgress--;
                if (res.id){
                    updateId(tempId, res.id);
                }
                onRequestSuccess(true);
            }
        });
    }

    /**
     *  Displays the edit book page for the passed in book.
     */
    function showEdit(id) {
        var title = document.getElementById('title' + id).innerHTML;
        var author = document.getElementById('author' + id).innerHTML;
        var price = document.getElementById('price' + id).innerHTML;
        var book = {id: id, title: title, author: author, price: price};
        loadTemplate('edit', {book: book});
    }

    /**
     *  Uses Ajax to get update the book on the server.  Calls loadList on success.
     */
    function updateBook(id) {
        var title = document.getElementById('edittitle' + id).value;
        var author = document.getElementById('editauthor' + id).value;
        var price = document.getElementById('editprice' + id).value;

        //Update in storage
        var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
        var currentItem = findStoredRecord(id);
        var lock = currentItem.item.lock;
        currentItem.item.title = title;
        currentItem.item.author = author;
        currentItem.item.price = price;
        currentItem.item.lock = true;
        storedList[currentItem.index] = currentItem.item;
        BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(storedList));

        //Refresh grid from storage
        loadList(null, true);

        //Check if it is a new ID that has not been confirmed by the server yet
        if (currentItem.item.id === currentItem.item.tempId){
            BOOK_NS.updated[currentItem.item.tempId] = true;
        }
        //Check if we already have a request out on this item
        else if (lock){
            BOOK_NS.updated[currentItem.item.id] = true;
        }
        else {
            updateServer(currentItem.item);
        }
    }

    /**
     * Calls the server to update the record
     */
    function updateServer(currentItem){
        //lock item to ensure no other requests get sent on it until this one returns
        lock(currentItem.id, true);

        //Make Ajax Request and load from server on success
        BOOK_NS.reqsInProgress++;
        $.ajax({
            url: '/api/books/' + currentItem.id,
            data: 'title=' + currentItem.title + '&author=' + currentItem.author + '&price=' + currentItem.price,
            type: 'PUT',
            timeout:5000,
            requestAttempts: 1,
            error:onRequestError,
            success: function(){
                //unlock item
                lock(currentItem.id,false);

                BOOK_NS.reqsInProgress--;

                if (BOOK_NS.updated[currentItem.id]){
                    var updatedItem = findStoredRecord(currentItem.id);
                    delete BOOK_NS.updated[currentItem.id];
                    updateServer(updatedItem.item);
                }
                else {
                    onRequestSuccess(true);
                }
            }
        });
    }

    /**
     * After successful edit/add/delete, we only want to update the list
     * IF the list page is showing AND if there are no more outstanding requests
     */
    function onRequestSuccess(noDecrement){
        //We handle this in the custom success for update so we don't want to do it here as well
        if (!noDecrement){
            BOOK_NS.reqsInProgress--;
        }

        if (!BOOK_NS.inEditMode && BOOK_NS.reqsInProgress === 0) {
            loadList();
        }
    }

    /**
     * Check if it is a timeout and if so, resend unless max timeouts per request was hit.
     * Also, note that if you are retrying on adds, you will get duplicates.  For production,
     * store tempId to ensure each row is only added once.
     *
     */
    function onRequestError(xhr, textStatus){
        if (textStatus === 'timeout') {
            if (this.requestAttempts < BOOK_NS.requestLimit) {
                this.requestAttempts++;
                $.ajax(this);
                return;
            }
        }

        //If we get to here, we are not going to retry, so just decrement the requests.
        //In production, would need to handle errors appropriately
        BOOK_NS.reqsInProgress--;
    }

    /**
     * Locks or unlocks the record to ensure that we never have two updates sent out at the same time
     * as there is no guarentee the order in which the updates will run.
     */
    function lock(id, lockBook){
        var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
        var record = findStoredRecord(id);
        record.item.lock = lockBook;
        storedList[record.index] = record.item;
        BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(storedList));
    }

    /**
     * Sets the permanent id for any new row
     * Sends any updates on given record to the server
     */
    function updateId(oldId, newId){
        //First check if the row has already been deleted from the client.
        if (BOOK_NS.deleted[oldId]){
            deleteFromServer(newId);
            delete BOOK_NS.deleted[oldId];
        }
        else {
            var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
            var currentItem = findStoredRecord(oldId, 'tempId');
            currentItem.item.id = newId;
            delete currentItem.item.tempId;
            storedList[currentItem.index] = currentItem.item;
            BOOK_NS.storage.setItem(BOOK_NS.storagePrefix + 'books', JSON.stringify(storedList));

            //check to see if row has been updated since initial add.  If so, send update to the server
            if (BOOK_NS.updated[oldId]){
                updateServer(currentItem.item);
                delete BOOK_NS.updated[oldId];
            }
        }
    }

    /**
     * Utility to generate random ID for add
     * NOTE:  This is a POC example.  This will not generate guaranteed unique numbers!
     */
    function getId(){
        return (Math.floor(Math.random()*90000) + 10000);
    }

    /**
     * Utility to get the row in localStorage that is being modified.
     * Can also search by arbitrary field by passing in the field parameter
     */
     function findStoredRecord(val, field){
        field = field || 'id';
        var storedList = JSON.parse(BOOK_NS.storage.getItem(BOOK_NS.storagePrefix + 'books'));
        var count = storedList.length;
        for (var i=0;i<count;i++){
            if (parseInt(storedList[i][field],10) === val){
                return {item:storedList[i], index:i};
            }
        }
        throw new Error(val + " not found");
     }

</script>
</body>
</html>