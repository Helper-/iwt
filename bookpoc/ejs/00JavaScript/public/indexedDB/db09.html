<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IndexedDB</title>
</head>
<body>
<div id="display"></div>
<div id="display1"></div>
<div id="display2"></div>
<div id="display3"></div>
<div id="display4"></div>
<script>

    document.addEventListener("DOMContentLoaded", function(event) {
        openDB(loadData);
    });

    /*  global variable used to maintain the database connection */
    var DB;

    /*
     Open the page's database for usage.  Added in checks for cross-browser support.
     */
    function openDB(callback){
        window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

        window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
        window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange

        /* NEW: We are going to add index to the data.
         This will take place in onupgradeneeded, so we will increase the value of the version to 3.
         NOTE:  We also changed the db name.  THIS is not normally necessary.  For our examples, it would
         break the earlier ones if we did not change the version on them as well, so we are changing the db name.
         In real life, all of your examples would update their version number on changes
         */
        var request = window.indexedDB.open("cse136-3", 3);

        /*  when the database successfully opens, it will return a reference to the database
         for future actions
         */
        request.onsuccess = function(e) {
            DB = e.target.result;
            callback();
        };

        /*  This is the only place to create object stores.
         We will create our 'team' store and specify that 'id' is the key
         */
        request.onupgradeneeded = function(e){
            var db = e.target.result;

            /*  We use autoIncrement: true for the key.  The key will be auto-generated when items are added.
             The key will be separate from the value object.
             */
            if(!db.objectStoreNames.contains('students')) {
                db.createObjectStore('students', { autoIncrement:true });
            }

            /*  We will set the keyPath to be the number field. The key will not be auto-generated.
             The key will be part of the value object.  The values in 'number' must be unique.
             */
            if(!db.objectStoreNames.contains('team')) {

                var teamStoreReq = db.createObjectStore('team', {keyPath:'number'});


                /*  We are going to add the initial data to the students store */
                var initialData = [
                    {number: 19, first: 'Harrison', last: 'Barnes', position: 'Forward'},
                    {number: 30, first: 'Steph', last: 'Curry', position: 'Guard'},
                    {number: 23, first: 'Draymond', last: 'Green', position: 'Forward'},
                    {number: 9, first: 'Andre', last: 'Iguodala', position: 'Guard'},
                    {number: 34, first: 'Shaun', last: 'Livingston', position: 'Guard'},
                    {number: 11, first: 'Clay', last: 'Thompson', position: 'Guard'},
                    {number: 12, first: 'Andrew', last: 'Bogut', position: 'Center'},
                ];

                teamStoreReq.createIndex("first", "first", { unique: true });
                teamStoreReq.createIndex("position", "position", { unique: false });

                /*  We ensure that the store is created before adding the data */
                teamStoreReq.transaction.oncomplete = function(evt) {
                    var teamStore = db.transaction("team", "readwrite").objectStore("team");

                    /*  Loop through and add the data.  We don't need to keep track of success
                     since it won't call the onsuccess of the initial request until completed */
                    for (var i= 0; i< initialData.length; i++) {
                        teamStore.add(initialData[i]);
                    }
                };
            }
            else{
                var teamStore = e.target.transaction.objectStore('team');

                /* NEW: Format of createIndex is indexName, pathName, options */
                teamStore.createIndex("first", "first", { unique: true });
                teamStore.createIndex("position", "position", { unique: false });
            }
        };

        request.onerror = function(e) {
            console.log(e);
        };

    }

    function loadData(){

        /*  We are going to change the adding of initial data to ONLY add if there is no current data.
         We can also add initial data when we create the store as we will see in future examples
         We use the .count method on the store to see if there is any data yet.  */

        /*  We are going to add the initial data to the students store */
        var initialData = [
            {first: 'Ali', last: 'Sorenson', age:20, hometown: 'San Francisco', gender: 'F'},
            {first: 'Keira', last: 'Sorenson', age:19, hometown: 'San Francisco', gender: 'F' },
            {first: 'Gavin', last: 'Birmingham', age:21, hometown: 'San Diego', gender:'M' },
            {first: 'Evy', last: 'Grant', age:20, hometown: 'New York', gender:'F' }
        ];

        /*  Open a transaction for modifying the students store.
         We will see in future examples that you can pass multiple stores in the form of an array.
         We can also chain together a few lines.  */
        var trans = DB.transaction('students', 'readwrite');

        /* Get reference to the students store */
        var studentStore = trans.objectStore('students');

        /*  Check the count of the store */
        var count = studentStore.count();
        var msg = 'Database ' + DB.name + ' version ' + DB.version + ' successfully opened.';

        count.onsuccess = function() {

            /* Only add the data if the count is 0 */
            if (count.result === 0) {
                /*  Since we are adding more than one row, we need to make sure we don't call our report function until
                 all rows are successfully added.  We will keep track of the success calls and once we have all of
                 them, we'll call the report function */

                var numRequests = initialData.length;

                for (var i= 0; i< initialData.length; i++) {
                    var request = studentStore.add(initialData[i]);

                    /*  Keep track of the number of requests so that we only call report after all have been added */
                    request.onsuccess = function(){
                        if (--numRequests === 0){
                            report(msg);
                        }
                    };
                }
            }
            else{
                /* If data is already added, just call report() */
                report(msg);
            }
        };
    }

    /*  Simplified report for single store.  Combo of report from db03 and db04 */
    function report(){
        /* Open up the team store.  We will chain the transaction and objectStore request together */
        var teamStore = DB.transaction('team').objectStore('team');

        var msg = '<h3>Record Setting Warriors:</h3><ul>';

        /*  NEW:  List all team members, but use the index to list in first name order */
        var nameIndex = teamStore.index("first");
        nameIndex.getAll().onsuccess = function(e) {
            var records = e.target.result;
            for (var j = 0; j < records.length; j++) {
                msg += '<li>' + JSON.stringify(records[j]) + '</li>';
            }
            msg += '</ul>';

            document.getElementById('display').innerHTML = msg;
        };

        /*  NEW:  Loop through the items in reverse name order */
        var msg1 = '<h3>Warriors in Reverse Order:</h3><ul>';
        nameIndex.openCursor(null, "prev").onsuccess = function(event) {
            var cursor = event.target.result;
            if (cursor) {
                msg1 += '<li>' +JSON.stringify(cursor.value) + '</li>';
                cursor.continue();
            }
            else{
                msg1 += '</ul>';
                document.getElementById('display1').innerHTML = msg1;
            }
        };

        listIndex();
    }

    /*  NEW: Here we will explore several other ways to search by index
    *   For all of the index searches, we can pass in an IDBKeyRange to
    *   restrict the data.  In this function, we will explore the various properties
    *   of the IDBKeyRange.
    * */
    function listIndex(){
        var teamStore = DB.transaction('team').objectStore('team');
        var nameIndex = teamStore.index("first");

        /* Match any first names alphabetically until "Draymond" */
        var upperBoundKeyRange = IDBKeyRange.upperBound('Draymond');
        var msg1 = '<h3>Warriors up until/including Draymond</h3><ul>';
        nameIndex.getAll(upperBoundKeyRange).onsuccess = function(e) {
            var records = e.target.result;
            for (var j = 0; j < records.length; j++) {
                msg1 += '<li>' + JSON.stringify(records[j]) + '</li>';
            }
            msg1 += '</ul>';

            document.getElementById('display2').innerHTML = msg1;
        };

        /*  The true as the second param means to not include the given name */
        var lowerBoundKeyRange = IDBKeyRange.lowerBound('Draymond', true);
        var msg2 = '<h3>Warriors after Draymond</h3><ul>';
        nameIndex.getAll(lowerBoundKeyRange).onsuccess = function(e) {
            var records = e.target.result;
            for (var j = 0; j < records.length; j++) {
                msg2 += '<li>' + JSON.stringify(records[j]) + '</li>';
            }
            msg2 += '</ul>';

            document.getElementById('display3').innerHTML = msg2;
        };

        /*  List all names between the two.  To not include the given names,
            you can set true for the 3rd and 4th parameters respectively
            false is default and not needed */
        var boundKeyRange = IDBKeyRange.bound("Clay", "Shaun", false, false);
        var msg3 = '<h3>Warriors between Clay and Shaun</h3><ul>';
        nameIndex.getAll(boundKeyRange).onsuccess = function(e) {
            var records = e.target.result;
            for (var j = 0; j < records.length; j++) {
                msg3 += '<li>' + JSON.stringify(records[j]) + '</li>';
            }
            msg3 += '</ul>';

            document.getElementById('display4').innerHTML = msg3;
        };

    }


</script>
</body>
</html>